{"/home/travis/build/npmtest/node-npmtest-npmd/test.js":"/* istanbul instrument in package npmtest_npmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npmd/lib.npmtest_npmd.js":"/* istanbul instrument in package npmtest_npmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_npmd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_npmd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-npmd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-npmd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_npmd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_npmd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_npmd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_npmd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_npmd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_npmd.__dirname + '/lib.npmtest_npmd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/index.js":"#!/usr/bin/env node\n\n'use strict'\n\nvar fs         = require('fs')\nvar path       = require('path')\nvar mkdirp     = require('mkdirp')\n\nvar levelup    = require('levelup')\n\nvar config     = require('npmd-config')\nvar commands   = require('./options')\nvar createCache = require('npmd-cache')\n\nif(config.version) {\n  console.log(require('./package').version)\n  process.exit()\n}\n\nvar medeadown = require('medeadown')\n\nvar db, cache\n\nfunction createDb (cb) {\n  levelup(\n    path.join(config.dbPath, config.jsdb ? 'jsdb' : 'db'),\n    {encoding: 'json', db: medeadown},\n    function (err, db) {\n      if(err && /No such file or directory/.test(err.message))\n        return mkdirp(config.dbPath, function (err) {\n          if(err) return cb(err)\n          createDb(cb)\n        })\n      if(err) return cb(err)\n      db.methods = {}\n      cache = createCache(db, config)\n      cb(null, db)\n    }\n  )\n}\n\nvar plugins = [\n  require('./plugins/resolve'),\n  require('./plugins/tree'),\n  require('./plugins/install'),\n  require('./plugins/help'),\n  require('./plugins/build'),\n  {commands: function (db) {\n    db.commands.push(function (db, cache, config, cb) {\n        fs.createReadStream(__dirname + '/docs/usage.md')\n        .on('close', function () {\n          cb()\n        })\n        .pipe(process.stdout)\n      return true\n      })\n    }\n  }\n]\n\nfunction addCommands(db) {\n  db.cli = db.commands = []\n  plugins.forEach(function (plug) {\n    var cli = plug.cli || plug.commands\n    if('function' === typeof cli)\n      cli(db, cache, config)\n  })\n}\n\nfunction addDb (db, cache, config) {\n  db.config = config\n  plugins.forEach(function (e) {\n    if('function' === typeof e.db)\n      e.db(db, cache, config)\n  })\n}\n\n//TODO: make a middleware like thing but with\n//cli commands.\n\nfunction execCommands (db, config, cb) {\n  if(!commands(db.commands) (db, cache, config, cb))\n    cb(new Error('unknown command'))\n}\n\ncreateDb(function(err, db){\n  if(err) throw err\n\n  //attach all plugins.\n  //process any commands.\n  addDb(db, cache, config)\n  addCommands(db, cache, config)\n\n  execCommands(db, config, function (err, data) {\n    if(err) throw err\n    if(data)\n      console.log(JSON.stringify(data, null, 2))\n    process.exit()\n  })\n})\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-config/index.js":"#! /usr/bin/env node\n\nvar path     = require('path')\nvar rc       = require('rc')\nvar minimist = require('minimist')\nvar toCC     = require('to-camel-case')\nvar fs       = require('fs')\nvar ini      = require('ini')\nvar osenv    = require('osenv')\n\nvar home     = osenv.home()\nvar tmp      = osenv.tmpdir()\n\nfunction obsfucate (s) {\n  return s.replace(/./g, '*')\n}\n\nfunction dumpConfig (config) {\n  var _config = JSON.parse(JSON.stringify(config))\n  if (_config.credentials)\n    _config.credentials.pass = obsfucate(_config.credentials.pass)\n  if (_config._auth)\n    _config._auth = obsfucate(_config._auth)\n  if (_config.Auth)\n    _config.Auth = obsfucate(_config.Auth)\n  console.log(JSON.stringify(_config, null, 2))\n}\n\nvar config = module.exports = (function () {\n  // *** vvv Copied this stuff out of npmconf **********************\n  var uidOrPid = process.getuid ? process.getuid() : process.pid\n\n  if (home) process.env.HOME = home\n  else home = path.resolve(tmp, \"npm-\" + uidOrPid)\n\n  var cacheExtra = process.platform === \"win32\" ? \"npm-cache\" : \".npm\"\n  var cacheRoot = process.platform === \"win32\" && process.env.APPDATA || home\n  var cache = path.resolve(cacheRoot, cacheExtra)\n  // *** ^^^ Copied this stuff out of npmconf **********************\n\n  // the defaults\n  var defaults = {\n    dbPath: path.join(home, '.npmd'),\n    debug: false,\n    sync: false,\n    registry: 'https://registry.npmjs.org',\n    cache: cache,\n    \"user-agent\" : \"node/\" + process.version\n                 + ' ' + process.platform\n                 + ' ' + process.arch,\n    prefix: (\n      process.env.PREFIX ||\n      ( process.platform === 'win32' ? path.dirname(process.execPath)\n      : path.dirname(path.dirname(process.execPath)))\n    ),\n    port: 5656,\n    global: false,\n    greedy: false,\n    online: true,\n    offline: false,\n    'save-dev': false,\n    saveDev: false,\n    save: false,\n  }\n\n  // merge ~/.npmrc on top of the defaults\n  if(home) try {\n    var c = ini.parse(fs.readFileSync(path.join(home, '.npmrc'), 'utf8'))\n    for (var k in c)\n      defaults[k] = c[k]\n  } catch(e) {}\n\n  var opts = require('minimist')(process.argv.slice(2),\n      {\n        boolean: [\n          'global', 'greedy', 'online', 'offline', 'save-dev',\n          'saveDev', 'save', 'force', 'optional'\n        ],\n        alias: {\n          global: 'g',\n          force: 'f',\n          'save-dev': 'D',\n          'save': 'S',\n          'dedupe': 'greedy'\n        },\n        default: {\n          global    : null,\n          greedy    : null,\n          online    : null,\n          offline   : null,\n          'save-dev': null,\n          saveDev   : null,\n          save      : null,\n          force     : null,\n          optional  : null\n        }\n      })\n\n  for(var k in opts)\n    if(null === opts[k])\n      delete opts[k]\n\n  // pass default and optimist to rc.\n  // note: we must clear the \n  var config = rc('npmd', defaults, opts)\n  var homePattern = process.platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n  if (config.prefix.match(homePattern) && home)\n    config.prefix = path.resolve(home, config.prefix.substr(2))\n\n  config.bin = config.bin ||\n  ( config.global ? path.join(config.prefix, 'bin')\n  : path.join(config.path || process.cwd(), 'node_modules', '.bin'))\n\n  if(!config.path && config.global)\n    config.path = path.join(config.prefix, 'lib')\n\n  for(var k in config)\n    config[toCC(k)] = config[k]\n\n  //parse credentials\n  if (config.Auth) {\n    var creds = Buffer(config.Auth, 'base64').toString()\n    var segs = creds.split(':')\n    config.credentials = { user: segs[0], pass: segs[1] }\n  }\n\n  if(config.showConfig) dumpConfig(config)\n  return config\n})()\n\n\nif(!module.parent)\n  dumpConfig(config)\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-config/node_modules/minimist/index.js":"module.exports = function (args, opts) {\n    if (!opts) opts = {};\n    \n    var flags = { bools : {}, strings : {}, unknownFn: null };\n\n    if (typeof opts['unknown'] === 'function') {\n        flags.unknownFn = opts['unknown'];\n    }\n\n    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {\n      flags.allBools = true;\n    } else {\n      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {\n          flags.bools[key] = true;\n      });\n    }\n    \n    var aliases = {};\n    Object.keys(opts.alias || {}).forEach(function (key) {\n        aliases[key] = [].concat(opts.alias[key]);\n        aliases[key].forEach(function (x) {\n            aliases[x] = [key].concat(aliases[key].filter(function (y) {\n                return x !== y;\n            }));\n        });\n    });\n\n    [].concat(opts.string).filter(Boolean).forEach(function (key) {\n        flags.strings[key] = true;\n        if (aliases[key]) {\n            flags.strings[aliases[key]] = true;\n        }\n     });\n\n    var defaults = opts['default'] || {};\n    \n    var argv = { _ : [] };\n    Object.keys(flags.bools).forEach(function (key) {\n        setArg(key, defaults[key] === undefined ? false : defaults[key]);\n    });\n    \n    var notFlags = [];\n\n    if (args.indexOf('--') !== -1) {\n        notFlags = args.slice(args.indexOf('--')+1);\n        args = args.slice(0, args.indexOf('--'));\n    }\n\n    function argDefined(key, arg) {\n        return (flags.allBools && /^--[^=]+$/.test(arg)) ||\n            flags.strings[key] || flags.bools[key] || aliases[key];\n    }\n\n    function setArg (key, val, arg) {\n        if (arg && flags.unknownFn && !argDefined(key, arg)) {\n            if (flags.unknownFn(arg) === false) return;\n        }\n\n        var value = !flags.strings[key] && isNumber(val)\n            ? Number(val) : val\n        ;\n        setKey(argv, key.split('.'), value);\n        \n        (aliases[key] || []).forEach(function (x) {\n            setKey(argv, x.split('.'), value);\n        });\n    }\n\n    function setKey (obj, keys, value) {\n        var o = obj;\n        keys.slice(0,-1).forEach(function (key) {\n            if (o[key] === undefined) o[key] = {};\n            o = o[key];\n        });\n\n        var key = keys[keys.length - 1];\n        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {\n            o[key] = value;\n        }\n        else if (Array.isArray(o[key])) {\n            o[key].push(value);\n        }\n        else {\n            o[key] = [ o[key], value ];\n        }\n    }\n    \n    function aliasIsBoolean(key) {\n      return aliases[key].some(function (x) {\n          return flags.bools[x];\n      });\n    }\n\n    for (var i = 0; i < args.length; i++) {\n        var arg = args[i];\n        \n        if (/^--.+=/.test(arg)) {\n            // Using [\\s\\S] instead of . because js doesn't support the\n            // 'dotall' regex modifier. See:\n            // http://stackoverflow.com/a/1068308/13216\n            var m = arg.match(/^--([^=]+)=([\\s\\S]*)$/);\n            var key = m[1];\n            var value = m[2];\n            if (flags.bools[key]) {\n                value = value !== 'false';\n            }\n            setArg(key, value, arg);\n        }\n        else if (/^--no-.+/.test(arg)) {\n            var key = arg.match(/^--no-(.+)/)[1];\n            setArg(key, false, arg);\n        }\n        else if (/^--.+/.test(arg)) {\n            var key = arg.match(/^--(.+)/)[1];\n            var next = args[i + 1];\n            if (next !== undefined && !/^-/.test(next)\n            && !flags.bools[key]\n            && !flags.allBools\n            && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                setArg(key, next, arg);\n                i++;\n            }\n            else if (/^(true|false)$/.test(next)) {\n                setArg(key, next === 'true', arg);\n                i++;\n            }\n            else {\n                setArg(key, flags.strings[key] ? '' : true, arg);\n            }\n        }\n        else if (/^-[^-]+/.test(arg)) {\n            var letters = arg.slice(1,-1).split('');\n            \n            var broken = false;\n            for (var j = 0; j < letters.length; j++) {\n                var next = arg.slice(j+2);\n                \n                if (next === '-') {\n                    setArg(letters[j], next, arg)\n                    continue;\n                }\n                \n                if (/[A-Za-z]/.test(letters[j])\n                && /-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n                    setArg(letters[j], next, arg);\n                    broken = true;\n                    break;\n                }\n                \n                if (letters[j+1] && letters[j+1].match(/\\W/)) {\n                    setArg(letters[j], arg.slice(j+2), arg);\n                    broken = true;\n                    break;\n                }\n                else {\n                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);\n                }\n            }\n            \n            var key = arg.slice(-1)[0];\n            if (!broken && key !== '-') {\n                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])\n                && !flags.bools[key]\n                && (aliases[key] ? !aliasIsBoolean(key) : true)) {\n                    setArg(key, args[i+1], arg);\n                    i++;\n                }\n                else if (args[i+1] && /true|false/.test(args[i+1])) {\n                    setArg(key, args[i+1] === 'true', arg);\n                    i++;\n                }\n                else {\n                    setArg(key, flags.strings[key] ? '' : true, arg);\n                }\n            }\n        }\n        else {\n            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {\n                argv._.push(\n                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n                );\n            }\n            if (opts.stopEarly) {\n                argv._.push.apply(argv._, args.slice(i + 1));\n                break;\n            }\n        }\n    }\n    \n    Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(argv, key.split('.'))) {\n            setKey(argv, key.split('.'), defaults[key]);\n            \n            (aliases[key] || []).forEach(function (x) {\n                setKey(argv, x.split('.'), defaults[key]);\n            });\n        }\n    });\n    \n    if (opts['--']) {\n        argv['--'] = new Array();\n        notFlags.forEach(function(key) {\n            argv['--'].push(key);\n        });\n    }\n    else {\n        notFlags.forEach(function(key) {\n            argv._.push(key);\n        });\n    }\n\n    return argv;\n};\n\nfunction hasKey (obj, keys) {\n    var o = obj;\n    keys.slice(0,-1).forEach(function (key) {\n        o = (o[key] || {});\n    });\n\n    var key = keys[keys.length - 1];\n    return key in o;\n}\n\nfunction isNumber (x) {\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-config/node_modules/ini/ini.js":"\nexports.parse = exports.decode = decode\nexports.stringify = exports.encode = encode\n\nexports.safe = safe\nexports.unsafe = unsafe\n\nvar eol = process.platform === \"win32\" ? \"\\r\\n\" : \"\\n\"\n\nfunction encode (obj, section) {\n  var children = []\n    , out = \"\"\n\n  Object.keys(obj).forEach(function (k, _, __) {\n    var val = obj[k]\n    if (val && Array.isArray(val)) {\n        val.forEach(function(item) {\n            out += safe(k + \"[]\") + \"=\" + safe(item) + \"\\n\"\n        })\n    }\n    else if (val && typeof val === \"object\") {\n      children.push(k)\n    } else {\n      out += safe(k) + \"=\" + safe(val) + eol\n    }\n  })\n\n  if (section && out.length) {\n    out = \"[\" + safe(section) + \"]\" + eol + out\n  }\n\n  children.forEach(function (k, _, __) {\n    var nk = dotSplit(k).join('\\\\.')\n    var child = encode(obj[k], (section ? section + \".\" : \"\") + nk)\n    if (out.length && child.length) {\n      out += eol\n    }\n    out += child\n  })\n\n  return out\n}\n\nfunction dotSplit (str) {\n  return str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002')\n         .replace(/\\\\\\./g, '\\u0001')\n         .split(/\\./).map(function (part) {\n           return part.replace(/\\1/g, '\\\\.')\n                  .replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001')\n        })\n}\n\nfunction decode (str) {\n  var out = {}\n    , p = out\n    , section = null\n    , state = \"START\"\n           // section     |key = value\n    , re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i\n    , lines = str.split(/[\\r\\n]+/g)\n    , section = null\n\n  lines.forEach(function (line, _, __) {\n    if (!line || line.match(/^\\s*[;#]/)) return\n    var match = line.match(re)\n    if (!match) return\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      p = out[section] = out[section] || {}\n      return\n    }\n    var key = unsafe(match[2])\n      , value = match[3] ? unsafe((match[4] || \"\")) : true\n    switch (value) {\n      case 'true':\n      case 'false':\n      case 'null': value = JSON.parse(value)\n    }\n\n    // Convert keys with '[]' suffix to an array\n    if (key.length > 2 && key.slice(-2) === \"[]\") {\n        key = key.substring(0, key.length - 2)\n        if (!p[key]) {\n          p[key] = []\n        }\n        else if (!Array.isArray(p[key])) {\n          p[key] = [p[key]]\n        }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    }\n    else {\n      p[key] = value\n    }\n  })\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  Object.keys(out).filter(function (k, _, __) {\n    if (!out[k] || typeof out[k] !== \"object\" || Array.isArray(out[k])) return false\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    var parts = dotSplit(k)\n      , p = out\n      , l = parts.pop()\n      , nl = l.replace(/\\\\\\./g, '.')\n    parts.forEach(function (part, _, __) {\n      if (!p[part] || typeof p[part] !== \"object\") p[part] = {}\n      p = p[part]\n    })\n    if (p === out && nl === l) return false\n    p[nl] = out[k]\n    return true\n  }).forEach(function (del, _, __) {\n    delete out[del]\n  })\n\n  return out\n}\n\nfunction isQuoted (val) {\n  return (val.charAt(0) === \"\\\"\" && val.slice(-1) === \"\\\"\")\n         || (val.charAt(0) === \"'\" && val.slice(-1) === \"'\")\n}\n\nfunction safe (val) {\n  return ( typeof val !== \"string\"\n         || val.match(/[\\r\\n]/)\n         || val.match(/^\\[/)\n         || (val.length > 1\n             && isQuoted(val))\n         || val !== val.trim() )\n         ? JSON.stringify(val)\n         : val.replace(/;/g, '\\\\;').replace(/#/g, \"\\\\#\")\n}\n\nfunction unsafe (val, doUnesc) {\n  val = (val || \"\").trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.substr(1, val.length - 2);\n    }\n    try { val = JSON.parse(val) } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    var esc = false\n    var unesc = \"\";\n    for (var i = 0, l = val.length; i < l; i++) {\n      var c = val.charAt(i)\n      if (esc) {\n        if (\"\\\\;#\".indexOf(c) !== -1)\n          unesc += c\n        else\n          unesc += \"\\\\\" + c\n        esc = false\n      } else if (\";#\".indexOf(c) !== -1) {\n        break\n      } else if (c === \"\\\\\") {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc)\n      unesc += \"\\\\\"\n    return unesc\n  }\n  return val\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/options.js":"\n\nmodule.exports = function (funs) {\n  if(!Array.isArray(funs))\n    funs = [].slice.call(arguments)\n\n  return function () {\n    var args = [].slice.call(arguments)\n    var called\n    for(var i in funs) {\n      if(called = funs[i].apply(null, args))\n        break;\n    }\n    return called\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/index.js":"#! /usr/bin/env node\n\nvar path      = require('path')\nvar CAS       = require('content-addressable-store')\nvar cache     = require('level-content-cache')\nvar request   = require('request')\nvar mkdirp    = require('mkdirp')\nvar npmUrl    = require('npmd-url')\nvar levelup   = require('levelup')\nvar medeadown = require('medeadown')\n\nvar deterministic = require('./deterministic')\n\nvar createDefer = require('./defer')\n\nvar semver = require('semver')\nvar xft = require('extract-from-tarball')\n\nvar concat = require('concat-stream')\nvar streamify = require('streamify')\nvar EventEmitter = require('events').EventEmitter\n\nvar pull = require('pull-stream')\nvar pl = require('pull-level')\n\nmodule.exports = function (db, config) {\n  if(!config) config = db, db = null\n  if(!config) throw new Error('must have db and config')\n  if(!db)\n    db = levelup(\n      path.join(config.dbPath, config.jsdb ? 'jsdb' : 'db'),\n      {encoding: 'json', db: medeadown}\n    )\n\n  function unlock () {\n    require('fs').unlinkSync(\n      path.join(config.dbPath, config.jsdb ? 'jsdb' : 'db', 'medea.lock')\n    )\n    process.exit(1)\n  }\n\n  process.on('SIGINT', unlock)\n  process.on('SIGTERM', unlock)\n\n\n  var get, db, blobs, auth\n  var getter = new EventEmitter()\n\n  if (config.alwaysAuth) {\n    var creds = Buffer(config.Auth, 'base64').toString()\n    var segs = creds.split(':')\n    auth = { user: segs[0], pass: segs[1] }\n  }\n\n  var defer = createDefer()\n\n  mkdirp(config.dbPath, function () {\n\n    //***************************************************\n    //*** TODO: migrate to sha256.\n    //*** sha1 is insecure, but need it to be compatible with npm.\n    //***************************************************\n\n    blobs = CAS(path.join(config.dbPath, 'blobs'), 'sha1')\n\n    get = cache(db, blobs, {getter: function (key, meta, cb) {\n      var url = npmUrl (key, config)\n      //if it's a github url, must cleanup the tarball\n      //DO NOT DO THIS ON NPM REGISTRIES! It will break the shasum!!!\n      if(/^https?:\\/\\/[^/]*github.com/.test(url))\n        deterministic(request({url: url, encoding: null}), cb)\n      else\n        request({\n          url: url, encoding: null, auth: auth\n        }, function (err, response, body) {\n          if(err) return cb(err)\n\n          if(response.statusCode !== 200) {\n            return cb(new Error(\n              'error attemping to fetch: ' + url +\n              ' ' + body.toString()))\n          }\n          cb(null, body, {})\n        })\n    }})\n\n    defer.ready()\n  })\n\n  getter.get = defer(function () {\n    return get.apply(this, arguments)\n  })\n\n  //sometimes you want to add a module that\n  //hasn't actually been published yet.\n  //so stick it in, indexing only by it's hash.\n\n  //if it's actually published later, that is cool.\n\n  getter.addTarball = defer(function (buffer, opts, cb) {\n    return blobs.add(buffer, opts, cb)\n  })\n\n  //some times you need to delete something from the cache\n  //so you can debug the fetch code. that is what this is for.\n  getter._del = defer(function (key, cb) {\n    get._del(key, cb)\n  })\n\n  getter.allHashes = defer(function (cb) {\n    blobs.all(cb)\n  })\n\n  getter.allKeys = defer(function (cb) {\n    pull(pl.read(db, {keys: false}), pull.collect(cb))\n  })\n\n  var createStream = defer(function (id, cb) {\n    var key, hash\n    function getHash (hash, cb) {\n      if(!hash) throw new Error('no hash was provided')\n      blobs.has(hash, function (err) {\n        if(err) return cb(err)\n        cb(null, blobs.getStream(hash))\n      })\n    }\n\n    function getKey (key, opts, cb) {\n      if(!cb) cb = opts, opts = {}\n      get(key, opts, function (err, content, meta) {\n        if(err) return cb(err)\n        getHash(meta.hash, cb)\n      })\n    }\n\n    if(id.key && id.hash) {\n      getHash(id.hash, function (err, stream) {\n        if(err) {\n          if(err.code === 'ENOENT') getKey(id.key, cb)\n          else                      cb(err)\n          return\n        }\n\n        //Is this a security hole?\n        //I think we can't resolve that until there are signed packages anyway.\n        //sometimes we definately don't want to update this...\n        //like, when we are installing a prepublished hash, say for testing.\n        //the version number cannot be official until it's in the registry,\n        //because otherwise it'll be out of order. I needed this for offline\n        //resolve, but maybe the better way is to resolve from the .cache.json\n        //but filter to the tarballs that are in the content store?\n        //\n        //I was worried that would be slow -- a bloom filter would need to be saved\n        //what about if has kept a cache? yeah - doing a readdir and remembering the hashes would be very fast.\n\n//This should not be needed with the new offline resolve.\n//        db.get(id.key, function (err) {\n//          if(err)\n//            db.put(id.key, {\n//              key: id.key, hash: id.hash, ts: Date.now()              \n//            }, function () {})\n//        })\n//\n        cb(null, stream)\n      })\n    }\n    else if(blobs.isHash(id))\n      return getHash(id, cb)\n    else\n      return getKey(id, cb)\n\n  })\n\n  getter.createStream = function (key, cb) {\n    if(!cb) {\n      var stream = streamify()\n      return createStream(key, function (err, _stream) {\n        if(err) return stream.emit('error', err)\n        stream.resolve(_stream)\n      })\n      return stream\n    }\n    return createStream(key, cb)\n  }\n\n  //TODO this should use streams.\n\n  getter.resolve = defer(function (module, range, opts, cb) {\n    if(!cb) cb = opts, opts = {}\n    //it's a url\n    if(/\\//.test(range)) {\n      get(range, config, next)\n    }\n    else if(semver.valid(range, true))\n      get(module+'@'+range, config, next)\n    //it's a module\n    else if(/^[0-9a-f]{40,64}$/.test(range))\n      get(range, config, next)\n    else {\n      var versions = {}\n      db.createReadStream({start: module + '\\x00', end: module + '\\xff\\xff'})\n        .on('data', function (pkg) {\n          var parts = pkg.key.split('@')\n          var name = parts[0]\n          if(name !== module) return\n          var version = parts[1]\n          versions[version] = pkg.value\n        })\n        .on('end', function () {\n          var version = semver.maxSatisfying(Object.keys(versions), range, true)\n          if(!version) return cb(new Error('could not resolve' + module + '@' + range))\n\n          get(versions[version].hash, function (err, content) {\n            next(err, content, versions[version])\n          })\n        })\n\n    }\n\n    function next(err, data, meta) {\n      //**************************************************\n      //extract the package.json from data, and return it.\n      if(err) return cb(err)\n\n      xft(data, {package: xft.package}, function (err, out) {\n        if(err) return cb(err)\n        var pkg\n        try {\n          pkg = JSON.parse(out.package.source.toString('utf8'))\n          pkg.shasum = meta.hash\n        } catch (err) {\n          return cb(err)\n        }\n        cb(null, pkg)\n      })\n    }\n  })\n\n  return getter\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-url/index.js":"\n//TODO: redo all of this with tests and stuff...\n\nvar github = require('npm-github-resolve-url')\n\nmodule.exports = function (pkg, config) {\n  config = config || {}\n  var registry = config.registry || 'https://registry.npmjs.org'\n  var name, version, m\n  //pkg\n  function mvUrl(name, version) {\n    return registry + '/' + name + '/-/' + name + '-' + version + '.tgz'\n  }\n\n  if('object' === typeof pkg) {\n    if(pkg.tarball) return pkg.tarball\n    if(pkg.name && pkg.version)\n      return mvUrl(pkg.name, pkg.version)\n  }\n  //module@version\n  else if(m = /^([\\w._-]+)@(.*)$/.exec(pkg)) {\n    return mvUrl(m[1], m[2])\n  }\n\n  //handle multilpe type of github urls,\n  //including git urls (which will download from github http download api)\n  if(m = github(pkg))\n    return m\n\n  //http url\n  else if(/(https?:\\/\\/.+)/.test(pkg)) {\n    return pkg\n  }\n  \n  throw new Error('loading modules from format:' + JSON.stringify(pkg) + 'not yet implemented')\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/deterministic.js":"var dtar = require('deterministic-tar')\nvar zlib = require('zlib')\nvar path = require('path')\nvar concat = require('concat-stream')\n\n//unpack and repack a stream so that it always hashes the same,\n//by it's content, not it's timestamps.\n\nmodule.exports = function (stream, cb) {\n\n  \n  var offset = new Date().getTimezoneOffset() * -1\n  var THE_BEGINNING_OF_TIME = new Date(offset)\n\n  var buffer = []\n  var ended = false\n\n  function errback (err) {\n    if(ended) return\n    cb(ended = err)\n  }\n\n  stream\n    .on('error', errback)\n    .pipe(zlib.createGunzip())\n    .on('error', errback)\n    .pipe(dtar(function (header) {\n      var i = header.name.indexOf('/')\n      var dir = header.name.substring(0, i)\n      if(dir !== 'package')\n        header.name = 'package'+ header.name.substring(i)\n      return header\n    }))\n    .on('error', errback)\n    .pipe(zlib.createGzip())\n    .pipe(concat(function (data) {\n      if(ended) return\n      ended = true\n      cb(null, data)\n    }))\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/defer.js":"module.exports = function createDefer () {\n  var waiting = [], ready = false\n  function defer (fun) {\n    if('function' !== typeof fun)\n      throw new Error('defer *must* be called with a function')\n    return function () {\n      var args = [].slice.call(arguments)\n      var self = this\n      if(!ready) \n        waiting.push(function () {\n          return fun.apply(self, args)\n        })\n      else\n        return fun.apply(self, args)\n    }\n  }\n\n  defer.ready = function () {\n    defer.ready = function () {\n      throw new Error('defer.ready() called twice')\n    }\n    ready = true\n    while(waiting.length)\n      waiting.shift()()\n  }\n\n  return defer\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/pull-stream/index.js":"var sources  = require('./sources')\nvar sinks    = require('./sinks')\nvar throughs = require('./throughs')\nvar u        = require('pull-core')\n\nfunction isFunction (fun) {\n  return 'function' === typeof fun\n}\n\nfunction isReader (fun) {\n  return fun && (fun.type === \"Through\" || fun.length === 1)\n}\nvar exports = module.exports = function pull () {\n  var args = [].slice.call(arguments)\n\n  if(isReader(args[0]))\n    return function (read) {\n      args.unshift(read)\n      return pull.apply(null, args)\n    }\n\n  var read = args.shift()\n\n  //if the first function is a duplex stream,\n  //pipe from the source.\n  if(isFunction(read.source))\n    read = read.source\n\n  function next () {\n    var s = args.shift()\n\n    if(null == s)\n      return next()\n\n    if(isFunction(s)) return s\n\n    return function (read) {\n      s.sink(read)\n      //this supports pipeing through a duplex stream\n      //pull(a, b, a) \"telephone style\".\n      //if this stream is in the a (first & last position)\n      //s.source will have already been used, but this should never be called\n      //so that is okay.\n      return s.source\n    }\n  }\n\n  while(args.length)\n    read = next() (read)\n\n  return read\n}\n\n\nfor(var k in sources)\n  exports[k] = u.Source(sources[k])\n\nfor(var k in throughs)\n  exports[k] = u.Through(throughs[k])\n\nfor(var k in sinks)\n  exports[k] = u.Sink(sinks[k])\n\nvar maybe = require('./maybe')(exports)\n\nfor(var k in maybe)\n  exports[k] = maybe[k]\n\nexports.Duplex  = \nexports.Through = exports.pipeable       = u.Through\nexports.Source  = exports.pipeableSource = u.Source\nexports.Sink    = exports.pipeableSink   = u.Sink\n\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/pull-stream/sources.js":"\nvar keys = exports.keys =\nfunction (object) {\n  return values(Object.keys(object))\n}\n\nvar once = exports.once =\nfunction (value) {\n  return function (abort, cb) {\n    if(abort) return cb(abort)\n    if(value != null) {\n      var _value = value; value = null\n      cb(null, _value)\n    } else\n      cb(true)\n  }\n}\n\nvar values = exports.values = exports.readArray =\nfunction (array) {\n  if(!Array.isArray(array))\n    array = Object.keys(array).map(function (k) {\n      return array[k]\n    })\n  var i = 0\n  return function (end, cb) {\n    if(end)\n      return cb && cb(end)  \n    cb(i >= array.length || null, array[i++])\n  }\n}\n\n\nvar count = exports.count = \nfunction (max) {\n  var i = 0; max = max || Infinity\n  return function (end, cb) {\n    if(end) return cb && cb(end)\n    if(i > max)\n      return cb(true)\n    cb(null, i++)\n  }\n}\n\nvar infinite = exports.infinite = \nfunction (generate) {\n  generate = generate || Math.random\n  return function (end, cb) {\n    if(end) return cb && cb(end)\n    return cb(null, generate())\n  }\n}\n\nvar defer = exports.defer = function () {\n  var _read, cbs = [], _end\n\n  var read = function (end, cb) {\n    if(!_read) {\n      _end = end\n      cbs.push(cb)\n    } \n    else _read(end, cb)\n  }\n  read.resolve = function (read) {\n    if(_read) throw new Error('already resolved')\n    _read = read\n    if(!_read) throw new Error('no read cannot resolve!' + _read)\n    while(cbs.length)\n      _read(_end, cbs.shift())\n  }\n  read.abort = function(err) {\n    read.resolve(function (_, cb) {\n      cb(err || true)\n    })\n  }\n  return read\n}\n\nvar empty = exports.empty = function () {\n  return function (abort, cb) {\n    cb(true)\n  }\n}\n\nvar depthFirst = exports.depthFirst =\nfunction (start, createStream) {\n  var reads = []\n\n  reads.unshift(once(start))\n\n  return function next (end, cb) {\n    if(!reads.length)\n      return cb(true)\n    reads[0](end, function (end, data) {\n      if(end) {\n        //if this stream has ended, go to the next queue\n        reads.shift()\n        return next(null, cb)\n      }\n      reads.unshift(createStream(data))\n      cb(end, data)\n    })\n  }\n}\n//width first is just like depth first,\n//but push each new stream onto the end of the queue\nvar widthFirst = exports.widthFirst = \nfunction (start, createStream) {\n  var reads = []\n\n  reads.push(once(start))\n\n  return function next (end, cb) {\n    if(!reads.length)\n      return cb(true)\n    reads[0](end, function (end, data) {\n      if(end) {\n        reads.shift()\n        return next(null, cb)\n      }\n      reads.push(createStream(data))\n      cb(end, data)\n    })\n  }\n}\n\n//this came out different to the first (strm)\n//attempt at leafFirst, but it's still a valid\n//topological sort.\nvar leafFirst = exports.leafFirst = \nfunction (start, createStream) {\n  var reads = []\n  var output = []\n  reads.push(once(start))\n  \n  return function next (end, cb) {\n    reads[0](end, function (end, data) {\n      if(end) {\n        reads.shift()\n        if(!output.length)\n          return cb(true)\n        return cb(null, output.shift())\n      }\n      reads.unshift(createStream(data))\n      output.unshift(data)\n      next(null, cb)\n    })\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/pull-stream/sinks.js":"var drain = exports.drain = function (read, op, done) {\n\n  ;(function next() {\n    var loop = true, cbed = false\n    while(loop) {\n      cbed = false\n      read(null, function (end, data) {\n        cbed = true\n        if(end) {\n          loop = false\n          done && done(end === true ? null : end)\n        }\n        else if(op && false === op(data)) {\n          loop = false\n          read(true, done || function () {})\n        }\n        else if(!loop){\n          next()\n        }\n      })\n      if(!cbed) {\n        loop = false\n        return\n      }\n    }\n  })()\n}\n\nvar onEnd = exports.onEnd = function (read, done) {\n  return drain(read, null, done)\n}\n\nvar log = exports.log = function (read, done) {\n  return drain(read, function (data) {\n    console.log(data)\n  }, done)\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/pull-stream/throughs.js":"var u      = require('pull-core')\nvar sources = require('./sources')\nvar sinks = require('./sinks')\n\nvar prop   = u.prop\nvar id     = u.id\nvar tester = u.tester\n\nvar map = exports.map = \nfunction (read, map) {\n  map = prop(map) || id\n  return function (end, cb) {\n    read(end, function (end, data) {\n      var data = !end ? map(data) : null\n      cb(end, data)\n    })\n  }\n}\n\nvar asyncMap = exports.asyncMap =\nfunction (read, map) {\n  if(!map) return read\n  return function (end, cb) {\n    if(end) return read(end, cb) //abort\n    read(null, function (end, data) {\n      if(end) return cb(end, data)\n      map(data, cb)\n    })\n  }\n}\n\nvar paraMap = exports.paraMap =\nfunction (read, map, width) {\n  if(!map) return read\n  var ended = false, queue = [], _cb\n\n  function drain () {\n    if(!_cb) return\n    var cb = _cb\n    _cb = null\n    if(queue.length)\n      return cb(null, queue.shift())\n    else if(ended && !n)\n      return cb(ended)\n    _cb = cb\n  }\n\n  function pull () {\n    read(null, function (end, data) {\n      if(end) {\n        ended = end\n        return drain()\n      }\n      n++\n      map(data, function (err, data) {\n        n--\n\n        queue.push(data)\n        drain()\n      })\n\n      if(n < width && !ended)\n        pull()\n    })\n  }\n\n  var n = 0\n  return function (end, cb) {\n    if(end) return read(end, cb) //abort\n    //continue to read while there are less than 3 maps in flight\n    _cb = cb\n    if(queue.length || ended)\n      pull(), drain()\n    else pull()\n  }\n  return highWaterMark(asyncMap(read, map), width)\n}\n\nvar filter = exports.filter =\nfunction (read, test) {\n  //regexp\n  test = tester(test)\n  return function next (end, cb) {\n    read(end, function (end, data) {\n      if(!end && !test(data))\n        return next(end, cb)\n      cb(end, data)\n    })\n  }\n}\n\nvar filterNot = exports.filterNot =\nfunction (read, test) {\n  test = tester(test)\n  return filter(read, function (e) {\n    return !test(e)\n  })\n}\n\nvar through = exports.through = \nfunction (read, op, onEnd) {\n  var a = false\n  function once (abort) {\n    if(a || !onEnd) return\n    a = true\n    onEnd(abort === true ? null : abort)\n  }\n\n  return function (end, cb) {\n    if(end) once(end)\n    return read(end, function (end, data) {\n      if(!end) op && op(data)\n      else once(end)\n      cb(end, data)\n    })\n  }\n}\n\nvar take = exports.take =\nfunction (read, test) {\n  var ended = false\n  if('number' === typeof test) {\n    var n = test; test = function () {\n      return n --\n    }\n  }\n\n  return function (end, cb) {\n    if(ended) return cb(ended)\n    if(ended = end) return read(ended, cb)\n\n    read(null, function (end, data) {\n      if(ended = ended || end) return cb(ended)\n      if(!test(data)) {\n        ended = true\n        read(true, function (end, data) {\n          cb(ended, data)\n        })\n      }\n      else\n        cb(null, data)\n    })\n  }\n}\n\nvar unique = exports.unique = function (read, field, invert) {\n  field = prop(field) || id\n  var seen = {}\n  return filter(read, function (data) {\n    var key = field(data)\n    if(seen[key]) return !!invert //false, by default\n    else seen[key] = true\n    return !invert //true by default\n  })\n}\n\nvar nonUnique = exports.nonUnique = function (read, field) {\n  return unique(read, field, true)\n}\n\nvar group = exports.group =\nfunction (read, size) {\n  var ended; size = size || 5\n  var queue = []\n\n  return function (end, cb) {\n    //this means that the upstream is sending an error.\n    if(end) return read(ended = end, cb)\n    //this means that we read an end before.\n    if(ended) return cb(ended)\n\n    read(null, function next(end, data) {\n      if(ended = ended || end) {\n        if(!queue.length)\n          return cb(ended)\n\n        var _queue = queue; queue = []\n        return cb(null, _queue)\n      }\n      queue.push(data)\n      if(queue.length < size)\n        return read(null, next)\n\n      var _queue = queue; queue = []\n      cb(null, _queue)\n    })\n  }\n}\n\nvar flatten = exports.flatten = function (read) {\n  var _read\n  return function (abort, cb) {\n    if(_read) nextChunk()\n    else      nextStream()\n\n    function nextChunk () {\n      _read(null, function (end, data) {\n        if(end) nextStream()\n        else    cb(null, data)\n      })\n    }\n    function nextStream () {\n      read(null, function (end, stream) {\n        if(end)\n          return cb(end)\n        if(Array.isArray(stream))\n          stream = sources.values(stream)\n        else if('function' != typeof stream)\n          throw new Error('expected stream of streams')\n        \n        _read = stream\n        nextChunk()\n      })\n    }\n  }\n}\n\nvar prepend =\nexports.prepend =\nfunction (read, head) {\n\n  return function (abort, cb) {\n    if(head !== null) {\n      if(abort)\n        return read(abort, cb)\n      var _head = head\n      head = null\n      cb(null, _head)\n    } else {\n      read(abort, cb)\n    }\n  }\n\n}\n\n//var drainIf = exports.drainIf = function (op, done) {\n//  sinks.drain(\n//}\n\nvar _reduce = exports._reduce = function (read, reduce, initial) {\n  return function (close, cb) {\n    if(close) return read(close, cb)\n    if(ended) return cb(ended)\n\n    sinks.drain(function (item) {\n      initial = reduce(initial, item)\n    }, function (err, data) {\n      ended = err || true\n      if(!err) cb(null, initial)\n      else     cb(ended)\n    })\n    (read)\n  }\n}\n\nvar nextTick = process.nextTick\n\nvar highWaterMark = exports.highWaterMark = \nfunction (read, highWaterMark) {\n  var buffer = [], waiting = [], ended, reading = false\n  highWaterMark = highWaterMark || 10\n\n  function readAhead () {\n    while(waiting.length && (buffer.length || ended))\n      waiting.shift()(ended, ended ? null : buffer.shift())\n  }\n\n  function next () {\n    if(ended || reading || buffer.length >= highWaterMark)\n      return\n    reading = true\n    return read(ended, function (end, data) {\n      reading = false\n      ended = ended || end\n      if(data != null) buffer.push(data)\n      \n      next(); readAhead()\n    })\n  }\n\n  nextTick(next)\n\n  return function (end, cb) {\n    ended = ended || end\n    waiting.push(cb)\n\n    next(); readAhead()\n  }\n}\n\n\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-cache/node_modules/pull-stream/maybe.js":"var u = require('pull-core')\nvar prop = u.prop\nvar id   = u.id\nvar maybeSink = u.maybeSink\n\nmodule.exports = function (pull) {\n\n  var exports = {}\n  var drain = pull.drain\n\n  var find = \n  exports.find = function (test, cb) {\n    return maybeSink(function (cb) {\n      var ended = false\n      if(!cb)\n        cb = test, test = id\n      else\n        test = prop(test) || id\n\n      return drain(function (data) {\n        if(test(data)) {\n          ended = true\n          cb(null, data)\n        return false\n        }\n      }, function (err) {\n        if(ended) return //already called back\n        cb(err === true ? null : err, null)\n      })\n\n    }, cb)\n  }\n\n  var reduce = exports.reduce = \n  function (reduce, acc, cb) {\n    \n    return maybeSink(function (cb) {\n      return drain(function (data) {\n        acc = reduce(acc, data)\n      }, function (err) {\n        cb(err, acc)\n      })\n\n    }, cb)\n  }\n\n  var collect = exports.collect = exports.writeArray =\n  function (cb) {\n    return reduce(function (arr, item) {\n      arr.push(item)\n      return arr\n    }, [], cb)\n  }\n\n  var concat = exports.concat =\n  function (cb) {\n    return reduce(function (a, b) {\n      return a + b\n    }, '', cb)\n  }\n\n  return exports\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/resolve.js":"var path    = require('path')\nvar ls      = require('npmd-tree').ls\nvar createResolve = require('npmd-resolve')\nvar deps    = require('get-deps')\n\nexports.db = function (db, cache, config) {\n\n  var resolve = createResolve(null, cache, config)\n  db.methods.resolve = {type: 'async'}\n  db.resolve = function (module, opts, cb) {\n    if(!cb) cb = opts, opts = {}\n    if(opts.hash) opts.greedy = false\n\n    if(!module || !module.length)\n      module = deps(process.cwd(), config)\n\n    ls(function (err, tree) {\n      if(err) return cb(err)\n      resolve(module,\n          merge({\n            greedy: opts.greedy,\n            available: tree\n          }, config),\n        cb\n      )\n    })\n  }\n}\n\nfunction merge (a, b) {\n  for(var k in b)\n    if(!a[k])\n      a[k] = b[k]\n  return a\n}\n\nexports.cli = function (db, cache) {\n  db.commands.push(function (db, cache, config, cb) {\n    var args = config._.slice()\n    var cmd = args.shift()\n    \n    if(cmd === 'resolve') {\n      db.resolve(args, config,\n        function (err, tree) {\n          if(err) return cb(err)\n          cb(null, tree)\n      })\n  \n      return true\n    }\n\n  })\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-tree/index.js":"#! /usr/bin/env node\nvar fs   = require('fs')\nvar path = require('path')\nvar pull = require('pull-stream')\nvar pfs  = require('pull-fs')\nvar paramap = require('pull-paramap')\nvar clean = require('./clean')\nvar cont = require('continuable')\nvar para = require('continuable-para')\n\nfunction filter () {\n  return pull(pull.filter(),\n    pull.map(function (pkg) {\n      return {\n        name   : pkg.name,\n        version: pkg.version,\n        path   : pkg.path\n      }\n    })\n  )\n}\n\nfunction first (cb) {\n  var f\n  return pull.drain(\n    function (data) { f = data; return false },\n    function (err) { cb(err === true ? null : err, f) }\n  )\n}\n\nvar readJson = cont.to(function (file, cb) {\n  fs.readFile(file, 'utf8', function (err, data) {\n    if(err) return cb(err)\n    var json\n    try { json = JSON.parse(data) }\n    catch (err) { return cb(err) }\n    json.path = path.dirname(file)\n    cb(null, json)\n  })\n})\n\nvar exists = cont.to(function (file, cb) {\n  fs.stat(file, function (err, stat) {\n    cb(null, stat)\n  })\n})\n\n\nfunction readPackage (dir, cb) {\n  var pkg\n  para([\n    readJson(path.resolve(dir, 'package.json')),\n    exists(path.resolve(dir, 'binding.gyp'))\n  ]) (function (err, data) {\n    if(!err) {\n      pkg = data[0]\n      if(!!data[1])\n        pkg.gypfile = true\n      pkg.path = dir\n    }\n    cb(err, pkg)\n  })\n}\n\nfunction maybe(test) {\n  return function (arg, cb) {\n    test(arg, function (err, value) {\n      cb(null, value)\n    })\n  }\n}\n\n\nfunction findPackage (dir, cb) {\n  if(!cb) cb = dir, dir = null\n  dir = dir || process.cwd()\n\n  pull(\n    pfs.ancestors(dir),\n    pfs.resolve('package.json'),\n    pfs.isFile(),\n    pull.asyncMap(maybe(readJson)),\n    pull.filter(),\n    first(function (err, pkg) {\n      if(!pkg && !err) {\n        err = new Error('could not locate a package.json under '+dir)\n        err.code = 'nopkg'\n      }\n      cb(err, pkg)\n    })\n  )\n}\n\n//retrive the current files, \nfunction ls (dir, cb) {\n  if(!cb) cb = dir, dir = null\n\n  dir = dir || process.cwd()\n\n  pull(\n    pfs.ancestors(dir),\n    pfs.resolve('node_modules'),\n    pfs.star(),\n    pull.filter(Boolean),\n    paramap(maybe(readPackage)),\n    filter(),\n    pull.unique('name'),\n    pull.reduce(function (obj, val) {\n      if(!obj[val.name])\n        obj[val.name] = val\n      return obj\n    }, {}, function (err, obj) {\n      cb(err, obj)\n    })\n  )\n}\n\n//creates the same datastructure as resolve,\n//selecting all dependencies...\n\nfunction tree (dir, opts, cb) {\n  if(!cb)\n    cb = opts, opts = {}\n  var i = 0\n  findPackage(dir, function (err, pkg) {\n    if(err && err.code === 'nopkg') \n      pkg = {path: dir}\n    pull(\n      pull.depthFirst(pkg, function (pkg) {\n        pkg.tree = {}\n        return pull(\n          pfs.readdir(path.resolve(pkg.path, 'node_modules')),\n          paramap(maybe(readPackage)),\n          pull.filter(function (_pkg) {\n            if(!_pkg) return\n            _pkg.parent = pkg\n            \n            pkg.tree[_pkg.name] = _pkg\n            return pkg\n          })\n        )\n      }),\n      opts.post ? paramap(function (data, cb) {\n        //run a post install-style hook.\n        opts.post(data, cb)\n      }) : pull.through(),\n      pull.drain(null, function (err) {\n        err = err === true ? null : err\n        pkg = clean(pkg)\n        if('string' !== typeof pkg.name)\n          pkg = pkg.dependencies\n        cb(err, pkg)\n      })\n    )\n  })\n}\n\nexports.tree = tree\nexports.findPackage = findPackage\nexports.ls = ls\n\nif(!module.parent) {\n  var config = require('npmd-config')\n  var exec = require('child_process').exec\n  if(config.version) {\n    console.log(require('./package').version)\n    process.exit(0)\n  }\n\n  if(config.ls)\n    ls(process.cwd(), function (err, data) {\n      if(err) throw err\n      console.log(JSON.stringify(data, null, 2))\n    })\n  else if(config.pkg)\n    findPackage(process.cwd(), function (err, data) {\n      if(err) throw err\n      console.log(JSON.stringify(data, null, 2))\n    })\n  else {\n    config.post =\n      function (data, cb) {\n        if(!config.c) return cb(null, data)\n        var cp =\n          exec(config.c, {cwd: data.path}, function (err, stdout) {\n            cb(err, data)\n          })\n        cp.stdout.pipe(process.stdout)\n        cp.stderr.pipe(process.stderr)\n      }\n\n    var target = config._[0] || config.path || process.cwd()\n\n    if(!/^[./]/.test(target))\n      target =\n        path.join(config.path, 'node_modules', target)\n\n    if(config.verbose)\n      console.error('traversing tree starting at:', target)\n\n    tree(target, config, function (err, tree) {\n      if(err) throw err\n      if(!config.quiet || !config.c)\n        console.log(JSON.stringify(tree, null, 2))\n    })\n  }\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-tree/clean.js":"var fields = ['name', 'version', 'from', 'gypfile', 'shasum']\n\nfunction isEmpty (obj) {\n  for(var k in obj)\n    return false\n  return true\n}\n\nmodule.exports = function clean (pkg) {\n  var deps = pkg.dependencies || {}\n  var _deps = pkg.tree || {}\n\n//  var shasum = pkg.shasum\n  for(var k in pkg)\n    if(!~fields.indexOf(k))\n      delete pkg[k]\n\n//  pkg.shasum = shasum\n\n  for(var k in _deps) {\n    _deps[k].from = deps[k]\n    clean(_deps[k])\n  }\n\n  pkg.dependencies = _deps\n  if(isEmpty(_deps))\n    delete pkg.dependencies\n  return pkg\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/index.js":"#! /usr/bin/env node\n\nvar createResolvePackage = require('./resolve')\nvar createResolve        = require('./resolve-tree')\n\nmodule.exports = function (db, cache, config) {\n  return createResolve(createResolvePackage(cache, config))\n}\n\nif(!module.parent) {\n  var config = require('npmd-config')\n  var cache = require('npmd-cache')(null, config)\n  var args = config._\n  var resolvePackage = createResolvePackage(cache, config)\n  var resolve = createResolve(resolvePackage)\n  var getDeps = require('get-deps')\n  if(config.version) {\n    console.log(require('./package').version)\n    process.exit()\n  }\n\n  var data = ''\n  if(!process.stdin.isTTY)\n    process.stdin\n      .on('data', function (d) { data += d })\n      .on('end', function () {\n        resolve(JSON.parse(data), config, function (err, tree) {\n          if(err) throw err\n          console.log(JSON.stringify(tree, null, 2))\n        })\n\n      })\n  else {\n    if(!args.length)\n      args = getDeps(process.cwd(), {dev: true})\n    resolve(args, config, function (err, tree) {\n      if(err) throw err\n      console.log(JSON.stringify(tree, null, 2))\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/resolve.js":"var online = require('./online')\nvar offline = require('./offline')\nvar override = require('./override')\n\nvar path = require('path')\n\nfunction cascade(methods) {\n  return function () {\n    var args = [].slice.call(arguments)\n    var cb = args.pop()\n    ;(function next (i) {\n      methods[i].apply(null, args.concat(function (err, value) {\n        if(err) return cb(err)\n        if(value == null) return next(i + 1)\n        cb(null, value)\n      }))\n    })(0)\n  }\n}\n\nmodule.exports = function (cache, config) {\n  config.dbPath = (config.dbPath || path.join(process.env.HOME, '.npmd'))\n\n  return override(cascade([\n    function (m, v, opts, cb) {\n      if(opts.online === false || opts.offline)\n        return offline(m, v, opts, cb)\n      return online(m, v, opts, function (err, pkg) {\n        if(err && err.code === 'ENOTFOUND') {\n          console.error('npmd: network is ENOTFOUND. fallback to offline resolution')\n          opts.offline = true\n          return offline(m, v, opts, cb)\n        }\n        cb(err, pkg)\n      })\n    },\n    cache.resolve,\n    function (m, v, opts, cb) {\n      cb(new Error(\n        'could not resolve ' + m + '@' + v\n         + (opts.maxTimestamp ? '\\n  (published before: ' + opts.maxTimestamp + ')' : '')))\n    }\n  ]))\n}\n\nif(!module.parent) {\n  var opts = require('minimist')(process.argv.slice(2))\n  var parts = opts._[0].split('@')\n  var resolve = module.exports(null, opts)\n\n  resolve(parts[0], parts[1], opts, function (err, pkg) {\n    if(err) throw err\n    console.log(JSON.stringify(pkg, null, 2))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/online.js":"'use strict';\nvar request = require('request')\nvar fs = require('fs')\nvar path = require('path')\nvar url = require('url')\nvar semver = require('semver')\nvar mkdirp = require('mkdirp')\nvar npmUrl = require('npmd-url')\nvar pull   = require('pull-stream')\n\nfunction readJson(file, cb) {\n  fs.stat(file, function (err, stat) {\n    if(err) return cb(err)\n    fs.readFile(file, 'utf-8', function (err, json) {\n      if(err) return cb(err)\n      try { json = JSON.parse(json) } catch (err) { return cb(err) }\n      cb(null, json, stat)\n    })\n  })\n}\n\nvar chooser = require('./choose-from-registry')\n\nvar MIN  = 60*1000\nvar HOUR = 60*MIN\nvar DAY  = 24*HOUR\n\nmodule.exports = function (module, vrange, opts, cb) {\n  var headers = {}\n  var auth\n  var registry = opts.registry || 'https://registry.npmjs.org'\n  var cache = opts.cache || path.join(process.env.HOME, '.npm')\n\n  //only resolve module@semver (NOT urls - leave that to npmd-cache)\n\n  //it's a url/other protocol\n  if(/\\//.test(vrange)) return cb()\n\n  var u = url.resolve(registry, module)\n  var cachedfile = path.join(cache, module, '.cache.json')\n\n  if (opts['always-auth']) {\n    var creds = Buffer(opts['_auth'], 'base64').toString()\n    var segs = creds.split(':')\n    auth = { user: segs[0], pass: segs[1] }\n  }\n\n  var nowish = new Date()\n  var fetched = false\n  //stat & read the json file.\n  readJson(cachedfile, function (err, json, stat) {\n    if(!err)\n      headers['if-none-match'] = json._etag\n\n    if(json) {\n      //if the file is very new,\n\n      if(!opts.freshen && +stat.mtime > nowish - (opts.minAge || 10*MIN))\n        return next(null, json)\n\n      //if the file is not old, carry on and use it.\n      if(!opts.freshen && +stat.mtime > nowish - (opts.maxAge || DAY))\n        return next(null, json)\n\n    }\n\n    function fetch () {\n      fetched = true\n      request({\n        url: u, headers: headers, auth: auth\n      }, function (err, res, data) {\n\n        if(err) return cb(err)\n        console.error(''+res.statusCode, u)\n        //if the file was still current - update mtime, so will hit cache next time.\n\n        if(res.statusCode === 304)\n          return fs.utimes(cachedfile, nowish, nowish, function () {\n            next(null, json)\n          })\n\n        if(res.statusCode >= 400) {\n          return cb(new Error(res.statusCode + ' when requesting:' + module + '@' + vrange))\n        }\n\n        try { data = JSON.parse(data.toString('utf-8')) } catch (err) { return cb(err) }\n        data._etag = res.headers.etag\n\n        if(!data.versions)\n          return cb(new Error('package document invalid'))\n\n        //save the newly downloaded doc.\n        mkdirp(path.join(cache, module), function (err) {\n          if(err) return cb(err)\n          fs.writeFile(cachedfile, JSON.stringify(data), function (err) {\n            //put this into leveldb, if possible!\n            if('function' === typeof opts.onRegistry)\n               opts.onRegistry(data)\n            next(err, data)\n          })\n        })\n      })\n    }\n\n    function next (err, doc) {\n      if(err) return cb(err)\n      //read a singe value from the stream.\n      pull(\n        chooser(doc, vrange, opts),\n        pull.find(Boolean, cb)\n      )\n    }\n\n    // if the cache was too old, or missing,\n    // request doc from registry.\n    console.error('GET', u)\n    fetch()\n  })\n}\n\nif(!module.parent) {\n  var opts = require('minimist')(process.argv.slice(2))\n  var parts = opts._[0].split('@')\n  var name = parts.shift()\n  var range = parts.shift() || '*'\n  module.exports(name, range, opts, function (err, pkg) {\n    console.log(JSON.stringify(pkg, null, 2))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/node_modules/npmd-url/index.js":"\n//TODO: redo all of this with tests and stuff...\n\nvar github = require('npm-github-resolve-url')\n\nmodule.exports = function (pkg, config) {\n  config = config || {}\n  var registry = config.registry || 'https://registry.npmjs.org'\n  var name, version, m\n  //pkg\n  function mvUrl(name, version) {\n    return registry + '/' + name + '/-/' + name + '-' + version + '.tgz'\n  }\n\n  if('object' === typeof pkg) {\n    if(pkg.tarballUrl) return pkg.tarballUrl\n    if(pkg.name && pkg.version)\n      return mvUrl(pkg.name, pkg.version)\n  }\n  //module@version\n  else if(m = /^([\\w._-]+)@(.*)$/.exec(pkg)) {\n    return mvUrl(m[1], m[2])\n  }\n\n  //handle multilpe type of github urls,\n  //including git urls (which will download from github http download api)\n  if(m = github(pkg))\n    return m\n\n  //http url\n  else if(/(https?:\\/\\/.+)/.test(pkg)) {\n    return pkg\n  }\n  \n  throw new Error('loading modules from format:' + JSON.stringify(pkg) + 'not yet implemented')\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/choose-from-registry.js":"\nvar semver = require('semver')\nvar pull = require('pull-stream')\n\nfunction isHash(h) {\n  return /^[0-9a-f]{40}$/.test(h)\n}\n\n// given a document from the registry,\n// pick a version.\n\nfunction errstream (err) {\n  return function (_, cb) { cb(err) }\n}\n\nmodule.exports = function (doc, vrange, opts, cb) {\n\n  // if the version is a tag,\n  // set the version to the tagged version\n  if(doc['dist-tags'] && doc['dist-tags'][vrange])\n    vrange = doc['dist-tags'][vrange]\n\n  // ********************\n  // If there was no satisfying version,\n  // and we didn't actually *fetch* anything\n  // maybe it's only just been published.\n  // So, it might be a good idea to fetch that again\n  // enabled by --refetch ?\n  // need to test how often I actually run into this problem.\n  // ********************\n\n  // ********************\n  // filter modules by max publish timestamp\n  // this allows you to resolve a module as it would have resolved\n  // at a given point backwards in time.\n  // the intended use of this is mainly to make it possible to test\n  // npmd-resolve and have the output be deterministic.\n  // ********************\n\n  var versions =\n    Object.keys(doc.versions)\n    .sort(semver.compareLoose)\n    .reverse()\n    .map(function (v) { return doc.versions[v] })\n\n  if(opts.maxTimestamp)\n    versions = versions.filter(function (pkg) {\n      return doc.time[v.version] < opts.maxTimestamp\n    })\n\n  function choose(pkgs) {\n    pkgs.forEach(function (pkg) {\n      pkg.shasum = pkg.shasum || pkg.dist.shasum\n      pkg.tarball = pkg.dist.tarball\n    })\n    return pull.values(pkgs)\n  }\n\n  function reject(reason) {\n    return errstream(new Error(reason))\n  }\n\n  if(isHash(vrange)) {\n    for(var i in versions) {\n      var pkg = versions[i]\n      if(pkg.dist.shasum == vrange)\n        return choose([pkg])\n    }\n    return reject('cannot resolve hash:' + vrange)\n  }\n\n  versions = versions.filter(function (pkg) {\n    return semver.satisfies(pkg.version, vrange, true)\n  })\n\n  if(!versions.length)\n    return reject('no version satisfying:' +\n        JSON.stringify(vrange) +\n        ' expected one of ' + JSON.stringify(versions)\n      )\n  else\n    return choose(versions)\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/offline.js":"'use strict';\nvar semver = require('semver')\nvar fs = require('fs')\nvar path = require('path')\nvar pull = require('pull-stream')\nvar chooser = require('./choose-from-registry')\n\nfunction readJson(file, cb) {\n  fs.readFile(file, 'utf-8', function (err, json) {\n    if(err) return cb(err)\n    try { json = JSON.parse(json) } catch (err) { return cb(err) }\n    cb(null, json)\n  })\n}\n\nmodule.exports = function (module, vrange, opts, cb) {\n  if(/\\//.test(vrange))\n    return cb()\n\n  var cache = opts.cache || path.join(process.env.HOME, '.npm')\n\n  readJson(path.join(cache, module, '.cache.json'), function (err, doc) {\n    if(err) return cb()\n\n    if(!doc.versions)\n      return cb(new Error('package document invalid'))\n\n    pull(\n      chooser(doc, vrange, opts),\n      pull.asyncMap(function (pkg, cb) {\n\n        var filename = path.join(\n                        opts.dbPath, 'blobs',\n                        pkg.shasum.substring(0, 2),\n                        pkg.shasum.substring(2)\n                      )\n        fs.stat(filename, function (err, stat) {\n          if(err) cb()\n          else    cb(null, pkg)\n        })\n\n      }),\n      pull.find(Boolean, function (err, pkg) {\n        if(err) cb(err)\n        else if(pkg) cb(null, pkg)\n        else\n          cb(new Error('not found: ' + module + '@' + vrange\n            + ( opts.maxTimestamp\n              ? '\\n  (published before: ' + opts.maxTimestamp + ')'\n              : '')\n          ))\n      })\n    )\n//\n//    pull(\n//      pull.values(versions),\n//      pull.asyncMap(function (version, cb) {\n//        var hash = json.versions[version].dist.shasum\n//\n//        var pkg = json.versions[version]\n//        pkg.shasum = pkg.dist.shasum\n//        pkg.tarball = pkg.dist.tarball\n//\n//        var filename = path.join(\n//                        opts.dbPath, 'blobs',\n//                        hash.substring(0, 2),\n//                        hash.substring(2)\n//                      )\n//\n//        fs.stat(filename, function (err, stat) {\n//          if(err) cb()\n//          else    cb(null, pkg)\n//        })\n//\n//      }),\n//      pull.filter(function (pkg) {\n//        if(!pkg) return\n//        return semver.satisfies(pkg.version, vrange)\n//      }),\n//      pull.take(function (item) {\n//        found = true\n//        cb(null, item)\n//        return false\n//      }),\n//      pull.drain(null, function (err) {\n//        if(!found)\n//          cb(new Error('not found: ' + module + '@' + vrange\n//            + ( opts.maxTimestamp\n//              ? '\\n  (published before: ' + opts.maxTimestamp + ')'\n//              : '')\n//          ))\n//\n//      })\n//    )\n//\n  })\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/override.js":"\nvar semver = require('semver')\n\n/*\n\nif opts.override is non null, then resolve modules that match from there.\n\n{\n  //either pass in the package.json you want for that package.\n  foo: foo_package_json\n\n  //or pass in another valid range...\n  bar: {verison: '1.0.1', to: '~2.0.0'}\n  //this will replace any bar that can use 1.0.1 with something that matches ~2.0.0\n}\n\n*/\n\nfunction isPackage(pkg) {\n  return pkg.name && pkg.version && (pkg.dependencies || pkg.devDependencies)\n}\n\n\nmodule.exports = function (fallback) {\n\n  return function (module, vrange, opts, cb) {\n    if('string' === typeof opts.override) {\n      var or = {}\n      opts.override.split(',').map(function (e) {\n        var parts = e.split(/@|:/)\n        var module = parts.shift()\n        var to = parts.pop()\n        var version = parts.shift()\n        or[module] = {version: version || '*', target: to}\n      })\n      opts.override = or\n    }\n\n    //falback if there is no override for this module.\n    if(!opts.override || !opts.override[module])\n      return fallback(module, vrange, opts, cb)\n\n    //check if we can resolve this module with our override.\n\n    var r = opts.override[module]\n\n    if(semver.validRange(vrange, true) && semver.satisfies(r.version, vrange, true)) {\n      //if the entire package.json was passed in...\n      //that is all that we need to resolve this.\n      if(isPackage(r)) {\n        r.shasum = r.shasum || (r.dist && r.dist.shasum)\n        return cb(null, r)\n      }\n      else {\n        fallback(r.name || module, r.target, opts, function (err, pkg) {\n          if(!err) return cb(null, pkg)\n\n          err.message = 'Override failed. could not replace '\n            + module + '@' + r.version\n            + ' => ' + (r.name ? r.name + '@' : '') + r.target\n            + '\\n'\n            + err.message\n\n          cb(err)\n        })\n      }\n    }\n    else\n      //if the override version does not satisfy this version\n      //fallback to the default resolution.\n      fallback(module, vrange, opts, cb)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/resolve-tree.js":"var pull    = require('pull-stream')\nvar pt      = require('pull-traverse')\nvar semver  = require('semver')\nvar cat     = require('pull-cat')\nvar clean    = require('./clean')\nvar paramap  = require('pull-paramap')\n\nmodule.exports = createResolve\n\nfunction check(pkg, name, range) {\n  if(!pkg) return false\n  if(pkg.tree[name] && semver.satisfies(pkg.tree[name].version, range, true))\n    return true\n  return check(pkg.parent, name, range)\n}\n\nfunction fixModule (module) {\n  if('string' === typeof module) {\n  var parts = module.split('@')\n    return {name: parts.shift(), version: parts.shift() || '*'}\n  }\n  return module\n}\n\nfunction niceError(err, parent, name, range) {\n  if(!err) return\n  err.message = 'package: '\n  + parent.name + '@' + parent.version\n  + ' could not resolve '\n  + name + '@' + range\n  + '\\n' + err.message\n\n  return err\n}\n\nfunction merge (a, b) {\n  var c = {}\n  a = a || {}\n  b = b || {}\n  for(var k in a)\n    c[k] = a[k]\n  for(var k in b)\n    c[k] = b[k]\n  return c\n}\n\nfunction isPackage(pkg) {\n  return pkg.name && pkg.version && (pkg.dependencies || pkg.devDependencies)\n}\n\nfunction has(deps, module, vrange) {\n  if(!deps || !deps[module]) return false\n  return semver.satisfies(deps[module].version, vrange, true)\n}\n\nfunction hasDep(pkg, module, vrange) {\n  if(pkg.tree && has(pkg.tree, module, vrange)) return true\n  else if(pkg.parent)\n    return hasDep(pkg.parent, module, vrange)\n  return false\n}\n\nvar unresolved = {}\n\nfunction createResolve (resolvePackage) {\n\n  function resolveTree (module, opts, cb) {\n\n    module = fixModule(module)\n\n    var filter = opts.filter || function (pkg, root) {\n      if(!pkg) return\n      pkg.parent.tree[pkg.name] = pkg\n    }\n\n    if(!module) return cb(null, {})\n\n    //this is the root package - if we are resolving from a package.json\n    //we should just use that, instead of calling resolve pkg.\n    var root\n\n    if(isPackage(module)) tree(module)\n    else\n      resolvePackage(module.name, module.version, opts, function (err, pkg) {\n        if(err) return cb(err)\n        tree(pkg)\n      })\n\n    function tree (root) {\n      if(opts.available) {\n        root.parent = {tree: opts.available}\n      }\n      pull(cat([\n        pull.values([root]),\n        pt.depthFirst(root, function (pkg) {\n          var deps = merge(\n            pkg.dependencies || {},\n            opts.optional === false ? {} : pkg.optionalDependencies\n          )\n\n          //merge deps and dev deps if this is the root module and we are in --dev mode\n          if(opts.dev && pkg === root)\n            deps = pkg.dependencies = merge(pkg.devDependencies, deps)\n\n          pkg.tree = {}\n          return pull(\n            pull.values(Object.keys(deps)),\n            //this could be parallel,\n            //but it's not the bottle neck.\n            paramap(function (name, cb) {\n              //check if there is already a module that resolves this...\n              if(hasDep(pkg, name, deps[name])) return cb()\n              //filter out versions that we already have.\n              //if(opts.check !== false && check(pkg, name, deps[name]))\n              //  return cb()\n              unresolved[name + '@' + deps[name]] = true\n              resolvePackage(name, deps[name], opts, function (err, _pkg) {\n                delete unresolved[name + '@' + deps[name]]\n\n                cb(niceError(err, pkg, name, deps[name]), _pkg)\n              })\n            }),\n            pull.filter(),\n            pull.through(function (_pkg) {\n              _pkg.parent = pkg\n              filter(_pkg, root)\n            })\n          )\n        })\n      ]),\n      pull.drain(null, function (err) {\n        cb(err, clean(root))\n      }))\n    }\n  }\n\n  //install non-conflicting modules as low in the tree as possible.\n  function resolveTreeGreedy (module, opts, cb) {\n    if(!cb) cb = opts, opts = null\n\n    opts = opts || {}\n    opts.filter = function (pkg, root) {\n      if(!pkg) return\n      if(!root.tree[pkg.name]) {\n        root.tree[pkg.name] = pkg\n        pkg.parent = root\n      }\n      else {\n        pkg.parent.tree[pkg.name] = pkg\n      }\n      return pkg\n    }\n\n    resolveTree(module, opts, cb)\n  }\n\n  return function (module, opts, cb) {\n    if(!cb)\n      cb = opts, opts = {}\n\n    function resolve(module, cb) {\n      if(opts && opts.greedy)\n        resolveTreeGreedy(module, opts, cb)\n      else\n        resolveTree(module, opts, cb)\n    }\n\n    if(Array.isArray(module) && module.length > 1) {\n\n      var n = module.length, a = {}\n\n      module.forEach(function (m) {\n        resolve(m, next)\n      })\n\n      function next (err, tree) {\n        if(err) return n = 0, cb(err)\n        a[tree.name] = tree\n        if(--n) return\n        cb(null, a)\n      }\n\n    } else {\n      if(Array.isArray(module))\n        module = module.shift()\n\n      resolve(module, cb)\n    }\n  }\n}\n\n//This Should Never Happen.\nprocess.on('exit', function () {\n  var keys = Object.keys(unresolved)\n  if(keys.length)\n  throw new Error('resolve did not callback: ' + keys.join(', '))\n})\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-resolve/clean.js":"var fields = ['name', 'version', 'from', 'gypfile', 'shasum', 'tarball']\n\nmodule.exports = function clean (pkg) {\n  var deps = pkg.dependencies\n  var _deps = pkg.tree || {}\n\n  for(var k in pkg)\n    if(!~fields.indexOf(k))\n      delete pkg[k]\n\n  for(var k in _deps) {\n    _deps[k].from = _deps[k].from || deps[k]\n    clean(_deps[k])\n  }\n\n  pkg.dependencies = _deps\n\n  return pkg\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/tree.js":"var tree = require('npmd-tree')\n\nexports.cli = function (db) {\n  db.commands.push(function (db, cache, config, cb) {\n    var args = config._.slice()\n    var cmd = args.shift()\n  \n    if(cmd == 'tree') {\n      tree.tree(config.installPath, config, function (err, tree) {\n        if(err) throw err\n        cb(null, tree)\n      })\n    }\n    else if(cmd == 'ls')\n      tree.ls(config.installPath, function (err, tree) {\n        if(err) throw err\n        cb(null, tree)\n      })\n    else\n      return\n\n    return true\n  })\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/install.js":"var deps = require('get-deps')\nvar addDeps = require('add-deps')\nvar build = require('npmd-build')\nvar bin = require('npmd-bin')\nvar path = require('path')\n\nexports.commands = function (db, cache, config) {\n\n  if(!cache.get) throw new Error('must have cache')\n  var install = require('npmd-install')(cache)\n\n  db.commands.push(function (db, cache, config, cb) {\n    var args = config._.slice()\n    if('install' !== args.shift()) return\n\n    var _args = args.slice(), data = ''\n    if(!process.stdin.isTTY)\n      process.stdin\n        .on('data', function (d) { data += d })\n        .on('end', function () { doInstall(JSON.parse(data)) })\n    else\n      db.resolve(args.slice(), config, function (err, tree) {\n        if(err) return cb(err)\n        doInstall(tree)\n      })\n\n    function doInstall (tree) {\n      install(tree, config, function (err, installed) {\n        if(err) return cb(err)\n\n        if(config.save || config.saveDev)\n          addDeps(config.path || process.cwd(), installed, config, next)\n        else next()\n\n        function next () {\n        \n          build(_args[0], config, function (err) {\n\n            _args = _args.map(function (e) {\n              e = e.split('@').shift()\n              if(/^[./]/.test(e)) return e\n              return config.global\n                ? path.join(config.prefix, 'lib', 'node_modules', e)\n                : path.join(process.cwd(), 'node_modules', e)\n            })\n\n            bin.all(_args, config.bin, config, function (err) {\n              cb(err, installed)\n            })\n\n          })\n\n        }\n      })\n    }\n\n\n    return true\n  })\n}\n\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd-build/index.js":"#! /usr/bin/env node\n\nvar tree = require('npmd-tree').tree\nvar spawn = require('child_process').spawn\nvar path = require('path')\n\nvar nodeGyp = require.resolve('node-gyp/bin/node-gyp')\n\nvar rebuild = module.exports = function (target, config, cb) {\n  config.post =\n    function (pkg, cb) {\n      if(!pkg.gypfile) return cb(null, pkg)\n      var cp =\n        spawn(nodeGyp, ['rebuild'], {cwd: pkg.path})\n        .on('exit', function (code) {\n          cb(code === 0 ? null : new Error('node-gyp: non-zero exit'), pkg)\n        })\n        .on('error', cb)\n\n      cp.stdout.pipe(process.stdout)\n      cp.stderr.pipe(process.stderr)\n    }\n\n  target = target || config.path || process.cwd()\n\n  if(!/^[./]/.test(target))\n    target =\n      path.join(config.path || process.cwd(), 'node_modules', target)\n\n  tree(target, config, cb)\n}\n\nif(!module.parent) {\n  var config = require('npmd-config')\n  if(config.version)\n    return console.log(require('./package').version)\n\n  rebuild(process.cwd(), config, function (err) {\n    if(err) {\n      console.error('ERROR with node-gyp')\n      throw err\n    }\n  })\n\n  process.on('exit', console.error)\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/add.js":"var addDeps = require('add-deps')\n\nexports.cli = function (db) {\n\n  db.commands.push(function (db, config, cb) {\n    var args = config._.slice()\n    if(args.shift() !== 'add') return\n    addDeps(process.cwd(), args, config, cb)\n    return true\n  })\n\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/dependents.js":"exports.cli = function (db) {\n    var seen = {}\n    db.commands.push(function (db, config, cb) {\n        var args = config._.slice();\n        if (args.shift() != \"dependents\") return;\n\n        var modulenames = args;\n\n        db.sublevel('ver').createReadStream({\n        }).on('data', function (data) {\n            var pkg = data.value;\n\n            if (pkg.hasOwnProperty(\"dependencies\") && pkg.dependencies != null) {\n                var all = true;\n\n                modulenames.forEach(function (modulename) {\n                    if (!pkg.dependencies.hasOwnProperty(modulename))\n                        all = false;\n                });\n\n                // TODO: pipe this off into some stream other than process.stdout\n                if (all === true)\n                    if (config.verbose)\n                        console.log(pkg.name + \"@\" + pkg.version)\n                    else {\n                        if(seen[pkg.name]) return\n                        seen[pkg.name] = true\n                        console.log(pkg.name);\n                    }\n            }\n        }).on('end', cb);\n\n        return true;\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/help.js":"var fs = require('fs')\n\nexports.cli = function (db, config) {\n\n  db.commands.push(function (db, cache, config, cb) {\n    if(config._[0] !== 'help') return\n\n    fs.createReadStream(__dirname + '/../docs/' + (config._[1] || 'help') + '.md')\n    .on('end', cb)\n    .on('error', function () {\n      fs.readdir(__dirname + '/../docs/', function (err, list) {\n        console.log('npmd help \\n  ' + \n          list\n          .map(function (e) { return e.replace(/.md$/, '') })\n          .filter(function (e) { return e!== 'help' })\n          .sort().join(', ')\n        )\n        cb()\n      })\n      fs.createReadStream(__dirname + '/../docs/' + (config._[1] || 'help') + '.md')\n\n    })\n    .pipe(process.stdout)\n    \n    return true\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/packages.js":"\nexports.cli = function (db, config) {\n  db.commands.push(function (db, config, cb) {\n    var args = config._.slice()\n    if(args.shift() != 'packages') return\n    var module = args.shift() || ''\n    db.sublevel('pkg').createReadStream({\n      min: module , max: module + '~',\n      keys: false\n    }).on('data', function (data) {\n      var pkg = data\n      if(config.long)\n        console.log(JSON.stringify(pkg, null, 2))\n      else\n        console.log(pkg.name)\n    })\n    .on('end', cb)\n    return true\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/readme.js":"exports.cli = function (db, config) {\n  db.commands.push(function (db, config, cb) {\n    var args = config._.slice()\n    if(args.shift() != 'readme') return\n    var module = args.shift()\n    db.sublevel('pkg').get(module, function (err, data) {\n      // console.log(arguments)\n      if(err) return cb(err)\n      if(!data.readme)\n        console.log('sorry, readme file not found.')\n      else\n        console.log(data.readme)\n\n      cb(null, data.readme || data)\n    })\n    return true\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npmd/node_modules/npmd/plugins/versions.js":"\n\nexports.cli = function (db, config) {\n  db.commands.push(function (db, config, cb) {\n    var args = config._.slice()\n    if(args.shift() != 'versions') return\n    var module = args.shift()\n    db.sublevel('ver').createReadStream({\n      min: module + '!', max: module + '!~'\n    }).on('data', function (data) {\n      var pkg = data.value\n      if(config.long)\n        console.log(pkg)\n      else\n        console.log(pkg.name + '@' + pkg.version)\n    })\n    .on('end', cb)\n    return true\n  })\n}\n"}